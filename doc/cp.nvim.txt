*cp.nvim.txt*            Competitive programming plugin for Neovim

Author:  Barrett Ruth <br.barrettruth@gmail.com>
License: Same terms as Vim itself (see |license|)

==============================================================================
INTRODUCTION                                                        *cp.nvim*

cp.nvim is a competitive programming plugin that automates problem setup,
compilation, and testing workflow for online judges.

Supported platforms (for now!): AtCoder, Codeforces, CSES

==============================================================================
REQUIREMENTS                                                *cp-requirements*

- Neovim 0.10.0+
- Unix-like operating system
- uv package manager (https://docs.astral.sh/uv/)

==============================================================================
COMMANDS                                                        *cp-commands*

:CP                                                                     *:CP*
        cp.nvim uses a single :CP command with intelligent argument parsing:

        State Restoration ~
            :CP                 Restore state from current file.
                                Automatically detects platform, contest, problem,
                                and language from cached state. Use this after
                                switching files to restore your CP environment.

        Setup Commands ~
            :CP {platform} {contest_id}
                                Full setup: set platform and load contest metadata.
                                Scrapes test cases and creates source file.
                                Example: >
                                    :CP codeforces 1933
<
            :CP {platform} {contest_id}
                                Contest setup: set platform, load contest metadata,
                                and scrape ALL problems in the contest. This creates
                                source files for every problem and caches all test
                                cases for efficient bulk setup. Opens the first
                                problem after completion.
                                Example: >
                                    :CP atcoder abc324
                                    :CP codeforces 1951
<
        Action Commands ~
            :CP run             Toggle run panel for individual test cases.
                                Shows per-test results with redesigned
                                layout for efficient comparison.

            :CP debug
                                Same as above but with the debug mode configured
                                settings.

            :CP pick            Launch configured picker for interactive
                                platform/contest selection.

        Navigation Commands ~
            :CP next            Navigate to next problem in current contest.
                                Stops at last problem (no wrapping).


            :CP prev            Navigate to previous problem in current contest.
                                Stops at first problem (no wrapping).

            :CP {problem_id}    Jump to problem {problem_id} in a contest.
                                Requires that a contest has already been set up.

        Cache Commands ~
            :CP cache clear [contest]
                                Clear the cache data (contest list, problem
                                data, file states) for the specified contest,
                                or all contests if none specified.

            :CP cache read
                                View the cache in a pretty-printed lua buffer.
                                Exit with q.

Template Variables ~
                                                        *cp-template-vars*
    Command templates support variable substitution using `{variable}` syntax:

    • {source}      Source file path (e.g. "abc324a.cpp")
    • {binary}      Output binary path (e.g. "build/abc324a.run")
    • {contest}     Contest identifier (e.g. "abc324", "1933")
    • {problem}     Problem identifier (e.g. "a", "b")

    Example template: >
        build = { 'g++', '{source}', '-o', '{binary}', '-std=c++17' }
<    Would expand to: >
        g++ abc324a.cpp -o build/abc324a.run -std=c++17
<

==============================================================================
CONFIGURATION                                                   *cp-config*

Here's an example configuration with lazy.nvim: >lua

    {
      'barrett-ruth/cp.nvim',
      cmd = 'CP',
      build = 'uv sync',
      opts = {
        languages = {
          cpp = {
            extension = 'cc',
            commands = {
              build = { 'g++', '-std=c++17', '{source}', '-o', '{binary}' },
              run   = { '{binary}' },
              debug = { 'g++', '-std=c++17', '-fsanitize=address,undefined',
                        '{source}', '-o', '{binary}' },
            },
          },
          python = {
            extension = 'py',
            commands = {
              run   = { 'python', '{source}' },
              debug = { 'python', '{source}' },
            },
          },
        },
        platforms = {
          cses = {
            enabled_languages = { 'cpp', 'python' },
            default_language  = 'cpp',
            overrides = {
              cpp = { extension = 'cpp', commands = { build = { ... } } }
            },
          },
          atcoder = {
            enabled_languages = { 'cpp', 'python' },
            default_language  = 'cpp',
          },
          codeforces = {
            enabled_languages = { 'cpp', 'python' },
            default_language  = 'cpp',
          },
        },
        debug = false,
        ui = {
          run_panel = {
            ansi = true,
            diff_mode = 'vim',
            max_output_lines = 50,
          },
          diff = {
            git = {
              args = { 'diff', '--no-index', '--word-diff=plain',
                       '--word-diff-regex=.', '--no-prefix' },
            },
          },
          picker = 'telescope',
        },
      }
    }
<

By default, C++ (g++ with ISO C++17) and Python are preconfigured under
`languages`. Platforms select which languages are enabled and which one is
the default; per-platform overrides can tweak `extension` or `commands`.

For example, to run CodeForces contests with Python by default:

>lua
    {
      platforms = {
        codeforces = {
          enabled_languages = { 'cpp', 'python' },
          default_language  = 'python',
        },
      },
    }
<

Any language is supported provided the proper configuration. For example, to
run CSES problems with Rust using the single schema:

>lua
    {
      languages = {
        rust = {
          extension = 'rs',
          commands = {
            build = { 'rustc', '{source}', '-o', '{binary}' },
            run   = { '{binary}' },
          },
        },
      },
      platforms = {
        cses = {
          enabled_languages = { 'cpp', 'python', 'rust' },
          default_language  = 'rust',
        },
      },
    }
<

                                                               *cp.Config*
    Fields: ~
        {languages}     (table<string,|CpLanguage|>) Global language registry.
                        Each language provides an {extension} and {commands}.
        {platforms}     (table<string,|CpPlatform|>) Per-platform enablement,
                        default language, and optional overrides.
        {hooks}         (|cp.Hooks|) Hook functions called at various stages.
        {debug}         (boolean, default: false) Show info messages.
        {scrapers}      (string[]) Supported platform ids.
        {filename}      (function, optional)
                        function(contest, contest_id, problem_id, config, language): string
                        Should return full filename with extension.
                        (default: concatenates contest_id and problem_id, lowercased)
        {ui}            (|CpUI|) UI settings: run panel, diff backend, picker.

                                                         *cp.PlatformConfig*
    Replaced by |CpPlatform|. Platforms no longer inline language tables.

                                                             *CpPlatform*
    Fields: ~
        {enabled_languages} (string[]) Language ids enabled on this platform.
        {default_language}  (string)   One of {enabled_languages}.
        {overrides}         (table<string,|CpPlatformOverrides|>, optional)
                            Per-language overrides of {extension} and/or {commands}.

                                                           *CpLanguage*
    Fields: ~
        {extension}     (string) File extension without leading dot.
        {commands}      (|CpLangCommands|) Command templates.

                                                        *CpLangCommands*
    Fields: ~
        {build}         (string[], optional) For compiled languages.
                         Must include {source} and {binary}.
        {run}           (string[], optional) Runtime command.
                         Compiled: must include {binary}.
                         Interpreted: must include {source}.
        {debug}         (string[], optional) Debug variant; same token rules
                         as {build} (compiled) or {run} (interpreted).

                                                              *CpUI*
    Fields: ~
        {run_panel}     (|RunPanelConfig|) Test panel behavior configuration.
        {diff}          (|DiffConfig|) Diff backend configuration.
        {picker}        (string|nil) 'telescope', 'fzf-lua', or nil.

                                                        *cp.RunPanelConfig*
    Fields: ~
        {ansi}             (boolean, default: true) Enable ANSI color parsing
                           and highlighting.
        {diff_mode}        (string, default: "none") Diff backend: "none",
                           "vim", or "git".
        {max_output_lines} (number, default: 50) Maximum lines of test output.

                                                            *cp.DiffConfig*
    Fields: ~
        {git}           (|cp.DiffGitConfig|) Git diff backend configuration.

                                                         *cp.DiffGitConfig*
    Fields: ~
        {args}          (string[]) Command-line arguments for git diff.
                        Default: { 'diff', '--no-index', '--word-diff=plain',
                                  '--word-diff-regex=.', '--no-prefix' }
                        • --no-index: Compare files outside git repository
                        • --word-diff=plain: Character-level diff markers
                        • --word-diff-regex=.: Split on every character
                        • --no-prefix: Remove a/ b/ prefixes from output

                                                                *cp.Hooks*
    Fields: ~
        {before_run}    (function, optional) Called before test panel opens.
                        function(state: cp.State)
        {before_debug}  (function, optional) Called before debug build/run.
                        function(state: cp.State)
        {setup_code}    (function, optional) Called after source file is opened.
                        function(state: cp.State)

    Hook functions receive the cp.nvim state object (cp.State). See the state
    module documentation (lua/cp/state.lua) for available methods and fields.

    Example usage in hook: >lua
        hooks = {
          setup_code = function(state)
            print("Setting up " .. state.get_base_name())
            print("Source file: " .. state.get_source_file())
          end
        }
<

==============================================================================
WORKFLOW                                                        *cp-workflow*

For the sake of consistency and simplicity, cp.nvim extracts contest/problem
identifiers from URLs. This means that, for example, CodeForces/AtCoder
contests are configured by their round id rather than round number. See below.

==============================================================================
PLATFORM-SPECIFIC USAGE                                        *cp-platforms*

AtCoder ~
                                                             *cp-atcoder*
URL format: https://atcoder.jp/contests/abc123/tasks/abc123_a

Usage examples: >
    :CP atcoder abc324          " Contest setup: load contest metadata only

Codeforces ~
                                                          *cp-codeforces*
URL format: https://codeforces.com/contest/1234/problem/A

Usage examples: >
    :CP codeforces 1934         " Contest setup: load contest metadata only

CSES ~
                                                                *cp-cses*
URL format: https://cses.fi/problemset/task/1068

Usage examples: >
    :CP cses dynamic_programming           " Set up ALL problems from DP category

==============================================================================

COMPLETE WORKFLOW EXAMPLE                                       *cp-example*

Example: Setting up and solving AtCoder contest ABC324

1. Browse to https://atcoder.jp/contests/abc324

2. Set up entire contest (bulk setup): >
    :CP atcoder abc324
<   This scrapes ALL problems (A, B, C, D, ...), creates source files
   for each, downloads all test cases, and opens problem A.

3. Alternative: Set up single problem: >
    :CP atcoder abc324 a
<   This creates only a.cc and scrapes its test cases

4. Code your solution, then test: >
    :CP run
<   Navigate with j/k, run specific tests with <enter>
    Exit test panel with q or :CP run when done

5. Move to next problem: >
    :CP next
<   This automatically sets up problem B

6. Continue solving problems with :CP next/:CP prev navigation

7. Switch to another file (e.g. previous contest): >
    :e ~/contests/abc323/a.cpp
    :CP
<   Automatically restores abc323 contest context

8. Submit solutions on AtCoder website

==============================================================================
PICKER INTEGRATION                                              *cp-picker*

When picker integration is enabled in configuration, cp.nvim provides interactive
platform and contest selection using telescope.nvim or fzf-lua.

:CP pick                                                        *:CP-pick*
        Launch configured picker for interactive problem selection.
        Control Flow: Select Platform → Contest → Code!

        Requires picker = 'telescope' or picker = 'fzf-lua' in configuration.
        Requires corresponding plugin (telescope.nvim or fzf-lua) to be installed.

PICKER KEYMAPS                                                  *cp-picker-keys*
<c-r>   Force refresh contest list, bypassing cache.
        Useful when contest lists are outdated or incomplete

==============================================================================
RUN PANEL                                                           *cp-run*

The run panel provides individual test case debugging. Problem time/memory
limit constraints are in columns Time/Mem respectively. Used time/memory are
in columns Runtime/RSS respectively.

Interface ~

The run panel uses the following table layout: >

    ┌─────┬────────┬──────────────┬───────────┬──────────┬──────────┬─────────────┐
    │  #  │ Status │ Runtime (ms) │ Time (ms) │ RSS (MB) │ Mem (MB) │  Exit Code  │
    ├─────┼────────┼──────────────┼───────────┼──────────┼──────────┼─────────────┤
    │  1  │   AC   │     12.0     │   2000    │   123    │   256    │      0      │
    │ >2  │   WA   │    45.70     │   2000    │   100    │   256    │      1      │
    ├─────┴────────┴──────────────┴───────────┴──────────┴──────────┴─────────────┤
    │ Input:                                                                      │
    │ 5 3                                                                         │
    ├─────┬────────┬──────────────┬───────────┬──────────┬──────────┬─────────────┤
    │  3  │  TLE   │      9.0     │   2000    │   256    │   256    │ 136 (SIGBUS)│
    │  4  │  RTE   │      0.0     │   2000    │   256    │   256    │139 (SIGUSR2)│
    └─────┴────────┴──────────────┴───────────┴──────────┴──────────┴─────────────┘
    ┌─────────────────────────────────────────────────────────────────────────────┐
    │ Expected vs Actual                                                          │
    │ 423                                                                         │
    │ 100                                                                         │
    │ hello world                                                                 │
    └─────────────────────────────────────────────────────────────────────────────┘

Status Indicators ~

Test cases use competitive programming terminology with color highlighting:

    AC      Accepted (passed)
    WA      Wrong Answer (output mismatch)
    TLE     Time Limit Exceeded (timeout)
    MLE     Memory Limit Exceeded Error (heuristic)
    RTE     Runtime Error (other non-zero exit code)
    NA      Any other state
<

==============================================================================
ANSI COLORS AND HIGHLIGHTING                                    *cp-ansi*

cp.nvim provides comprehensive ANSI color support and highlighting for
compiler output, program stderr, and diff visualization.

If you cannot see color highlighting in your config, it is likely due to an
erroneous config. Most tools (GCC, Python, Clang, Rustc) color stdout based on
whether stdout is connected to a terminal. One can usually get aorund this by
leveraging flags to force colored output. For example, to force colors with GCC,
alter your config as follows:

    {
        commands = {
            build = {
                'g++',
                '-fdiagnostics-color=always',
                ...
            }
       }
    }


==============================================================================
HIGHLIGHT GROUPS                                            *cp-highlights*

Test Status Groups ~

    CpTestAC        Green foreground for AC status
    CpTestWA        Red foreground for WA status
    CpTestTLE       Orange foreground for TLE status
    CpTestMLE       Orange foreground for MLE status
    CpTestRTE       Purple foreground for RTE status
    CpTestNA        Gray foreground for remaining state

ANSI Color Groups ~

cp.nvim preserves ANSI colors from compiler output and program stderr using
a sophisticated parsing system. Colors are automatically mapped to your
terminal colorscheme via vim.g.terminal_color_* variables.

Diff Highlighting ~

The git diff backend uses Neovim's built-in highlight groups that automatically
adapt to your colorscheme:

    DiffAdd                 Highlights added text in git diffs
    DiffDelete              Highlights removed text in git diffs

==============================================================================
TERMINAL COLOR INTEGRATION                          *cp-terminal-colors*

ANSI colors automatically use the terminal's color palette through Neovim's
vim.g.terminal_color_* variables.

If your colorscheme doesn't set terminal colors, set them like so: >vim
    let g:terminal_color_1 = '#ff6b6b'
    ...

==============================================================================
HIGHLIGHT CUSTOMIZATION                             *cp-highlight-custom*

You can customize any highlight group by linking to existing groups or
defining custom colors: >lua

    -- Customize the color of "TLE" text in run panel:
    vim.api.nvim_set_hl(0, 'CpTestTLE', { fg = '#ffa500', bold = true })

    -- ... or the ANSI colors used to display stderr
    vim.api.nvim_set_hl(0, 'CpAnsiRed', {
        fg = vim.g.terminal_color_1 or '#ef4444'
    })
<

Place customizations in your init.lua or after the colorscheme loads to
prevent them from being overridden: >lua
    vim.api.nvim_create_autocmd('ColorScheme', {
        callback = function()
            -- Your cp.nvim highlight customizations here
            vim.api.nvim_set_hl(0, 'CpTestAC', { link = 'String' })
        end
    })
<

==============================================================================
RUN PANEL KEYMAPS                                           *cp-test-keys*

<c-n>   Navigate to next test case
<c-p>   Navigate to previous test case
t       Cycle through diff modes: none → git → vim
q       Exit run panel and restore layout
<c-q>   Exit interactive terminal and restore layout

Diff Modes ~

Three diff backends are available:

    none    Nothing
    vim     Built-in vim diff (default, always available)
    git     Character-level git word-diff (requires git, more precise)

The git backend shows character-level changes with [-removed-] and {+added+}
markers.

Execution Details ~

Test cases are executed individually using the same compilation and
execution pipeline, but with isolated input/output for
precise failure analysis.

==============================================================================
FILE STRUCTURE                                                  *cp-files*

cp.nvim creates the following file structure upon problem setup: >

    {problem_id}.{ext}              " Source file
    build/
      {problem_id}.run              " Compiled binary
    io/
      {problem_id}.n.cpin           " nth test input
      {problem_id}.n.cpout          " nth program output
      {problem_id}.expected         " Expected output
<
==============================================================================
HEALTH CHECK                                                    *cp-health*

Run |:checkhealth| cp to verify your setup.

 vim:tw=78:ts=8:ft=help:norl:
