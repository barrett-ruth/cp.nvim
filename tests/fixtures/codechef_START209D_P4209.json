{
  "category_name": "main",
  "contest_code": "START209D",
  "contest_name": "Starters 209 (Rated)",
  "status": "success",
  "submit_error": "You need to login to submit.",
  "is_verified": false,
  "problem_code": "P4209",
  "contest_category": "9",
  "problem_name": "Tactical Conversion",
  "intended_contest_code": "START209",
  "body": "This is an example problem statement in markdown, and a mini guide on writing statements. Please make sure to remove everything here before publishing your problem.\n\n- Codechef uses markdown for its problem statements. Markdown syntax can be found [here](https:\/\/github.com\/showdownjs\/showdown\/wiki\/Showdown's-Markdown-syntax). Note the `[text](link)` syntax to insert a hyperlink.\n- Codechef also uses $\\LaTeX$ to render mathematical expressions, and you are advised to make liberal use of it to make your statement look good.\n- Text can be made **bold** or *italicized*.\n- **Do not** use HTML tags (p, ul, li, pre, br, ...) in the statement.\n- To insert an image, first upload it to an online hosting service (for an official contest, ask a Codechef admin to do this for you \u2014 this is important) and then use the following syntax: `![alt text](link-to-image)`.\n- If your problem doesn't contain subtasks, ensure that the Subtasks section below is disabled and **all content is deleted from it**.\n\nIf you face any issues, either contact a Codechef admin directly or send us an email at help@codechef.com.\n\nBelow is an example problem statement that uses some of the above-mentioned features.\n\n---------\n\nChef has a simple undirected graph $G$ with $N$ vertices and $M$ edges. A [subgraph](https:\/\/mathworld.wolfram.com\/Subgraph.html) $H$ of $G$ is called *good* if:\n- $H$ is connected\n- $H$ contains all $N$ vertices of $G$\n- There is a unique path between any two vertices in $H$, using only edges in $H$\n\nCount the number of *good* subgraphs of $G$. Since this number might be large, report it modulo $10^9 + 7$.\n\nIn other news, here's a completely unrelated image:\n\n![](https:\/\/s3.amazonaws.com\/codechef_shared\/download\/Images\/START41\/ss3.png).\n\n\n<aside style='background: #f8f8f8;padding: 10px 15px;'><div>All submissions for this problem are available.<\/div><\/aside>",
  "problemComponents": {
    "constraints": "- $1 \\leq T \\leq 2\\cdot 10^5$\n- $1 \\leq N \\leq 2\\cdot 10^5$\n- $S$ is a binary string.\n- The sum of $N$ over all test cases won't exceed $2\\cdot 10^5$.",
    "constraintsState": true,
    "subtasks": "- **Subtask 1 (10 points):** $1 \\leq M \\leq 10$\n- **Subtask 2 (20 points):** The sum of $N$ across all test cases won't exceed $20$.\n- **Subtask 3 (70 points):** No further constraints.",
    "subtasksState": false,
    "statement": "You are given a **binary** string $S$ of length $N$, i.e. each character of $S$ is either $0$ or $1$.\n\nYou would like to convert every character of $S$ into $0$.  \nTo achieve this, you can perform the following operation:\n- Choose an index $i$ $(1 \\le i \\le N)$ such that $S_i = 1$, and change $S_i$ to $0$.\n\nHowever, there is one restriction:  \nYou cannot perform two consecutive operations on adjacent indices.  \nThat is, if you operate on the sequence of indices $i_1, i_2, \\ldots, i_k$, then for each $1 \\le j \\lt k$ the condition $|i_j - i_{j+1}| \\gt 1$ must hold.  \n\nDetermine whether it is possible to make the entire string consist of only zeros under these conditions.",
    "inputFormat": "- The first line of input contains a single integer $T$, denoting the number of test cases.\n- Each test case consists of two lines of input:\n  - The first line contains a single integer $N$ \u2014 the length of the binary string.\n  - The second line contains the binary string $S$ of length $N$, consisting only of characters `0` and `1`.\n",
    "inputFormatState": true,
    "outputFormat": "For each test case, output a single string on a new line \u2014 ``YES`` if it is possible to convert the entire string to all zeros under the given rule, or ``NO`` otherwise.\n\nYou may print each character of the string in uppercase or lowercase (for example, the strings `YES`, `yEs`, `yes`, and `yeS` will all be treated as identical).",
    "outputFormatState": true,
    "sampleTestCases": [
      {
        "id": "1",
        "input": "5\n2\n00\n3\n001\n3\n101\n3\n111\n2\n11\n",
        "output": "Yes\nYes\nYes\nNo\nNo",
        "explanation": "**Test case $1$:** No operations are needed.\n\n**Test case $2$:** There is a single $1$ at position $3$.  \nSimply perform one operation with $i = 3$, and the string becomes $000$ as desired.\n\n**Test case $3$:** There are two $1$'s, at positions $1$ and $3$.  \nPerform one operation with $i = 1$, and the next operation with $i = 3$, and we're done.\n\n**Test case $4$:** There are three ones, at positions $1, 2, 3$.  \nIt's not possible to operate on all of them, because:\n- If our first operation is on index $1$, the second operation cannot be index $2$ and so must be index $3$.  \nBut then after index $3$ we cannot operate on index $2$ anyway, so that index will continue to contain a $1$.\n- Similarly, the first operation being on index $3$ will leave us unable to operate on index $2$.\n- Finally, if the first operation is on index $2$, then the second operation cannot be on either index $1$ or index $3$ since they're both adjacent to it.\n\nThus, there's no way to make everything $0$.",
        "isDeleted": false
      }
    ]
  },
  "gumlet_video_url": "",
  "video_editorial_url": "https:\/\/youtu.be\/Q_FRlRcbgi4?si=c972y75SV8nrn319",
  "text_editorial_body": "<h1><a name=\"problem-link-1\" class=\"anchor\" href=\"#problem-link-1\"><\/a>PROBLEM LINK:<\/h1>\n<p><a href=\"https:\/\/www.codechef.com\/problems\/P4209\">Practice<\/a><br>\n<a href=\"https:\/\/www.codechef.com\/START209A\/problems\/P4209\">Contest: Division 1<\/a><br>\n<a href=\"https:\/\/www.codechef.com\/START209B\/problems\/P4209\">Contest: Division 2<\/a><br>\n<a href=\"https:\/\/www.codechef.com\/START209C\/problems\/P4209\">Contest: Division 3<\/a><br>\n<a href=\"https:\/\/www.codechef.com\/START209D\/problems\/P4209\">Contest: Division 4<\/a><\/p>\n<p><em><strong>Author:<\/strong><\/em> <a href=\"https:\/\/www.codechef.com\/users\/pols_agyi_pols\">pols_agyi_pols<\/a><br>\n<em><strong>Tester:<\/strong><\/em> <a href=\"https:\/\/www.codechef.com\/users\/kingmessi\">kingmessi<\/a><br>\n<em><strong>Editorialist:<\/strong><\/em> <a href=\"https:\/\/www.codechef.com\/users\/iceknight1093\">iceknight1093<\/a><\/p>\n<h1><a name=\"difficulty-2\" class=\"anchor\" href=\"#difficulty-2\"><\/a>DIFFICULTY:<\/h1>\n<p>Simple<\/p>\n<h1><a name=\"prerequisites-3\" class=\"anchor\" href=\"#prerequisites-3\"><\/a>PREREQUISITES:<\/h1>\n<p>None<\/p>\n<h1><a name=\"problem-4\" class=\"anchor\" href=\"#problem-4\"><\/a>PROBLEM:<\/h1>\n<p>You\u2019re given a binary string <span class=\"math\">S<\/span>.<br>\nIn one move, you can choose an index <span class=\"math\">i<\/span> such that <span class=\"math\">S_i = 1<\/span>, and set <span class=\"math\">S_i = 0<\/span>.<br>\nHowever, you cannot choose adjacent indices on consecutive moves.<\/p>\n<p>Is it possible to make <span class=\"math\">S<\/span> have only zeros, using some sequence of moves?<\/p>\n<h1><a name=\"explanation-5\" class=\"anchor\" href=\"#explanation-5\"><\/a>EXPLANATION:<\/h1>\n<p>Let\u2019s work out a few simple cases first.<\/p>\n<p>The most trivial case is when <span class=\"math\">S<\/span> already contains only zeros - here, clearly the answer is <code>Yes<\/code>, and no moves are needed.<\/p>\n<p>The second most trivial case is when <span class=\"math\">S<\/span> contains a single <span class=\"math\">1<\/span> - here again the answer is <code>Yes<\/code>, since there are no restrictions on our first move; meaning we can turn the sole <span class=\"math\">1<\/span> into a <span class=\"math\">0<\/span>.<\/p>\n<p>Next, consider the case when <span class=\"math\">S<\/span> contains two occurrences of <span class=\"math\">1<\/span>.<br>\nThere are two possibilities:<\/p>\n<ul>\n<li>Suppose the <span class=\"math\">1<\/span>'s are next to each other, i.e., <span class=\"math\">S_i = S_{i+1} = 1<\/span> for some index <span class=\"math\">i<\/span>.<br>\nHere, the answer is clearly <code>No<\/code>, since after operating on one index we cannot operate on the other one.<\/li>\n<li>Suppose the <span class=\"math\">1<\/span>'s are not next to each other.<br>\nThen the answer is <code>Yes<\/code>, since operating on both ones is safe.<\/li>\n<\/ul>\n<p>Next, we look at the case when <span class=\"math\">S<\/span> contains three occurrences of <span class=\"math\">1<\/span>.<br>\nHere, it\u2019s again easy to see that if all three ones are contiguous (i.e. <span class=\"math\">S_i = S_{i+1} = S_{i+2} = 1<\/span> for some <span class=\"math\">i<\/span>) then the answer is <code>No<\/code>; and otherwise the answer is <code>Yes<\/code>.<\/p>\n<hr>\n<p>Naturally, the next step is to look at when <span class=\"math\">S<\/span> contains four occurrences of <span class=\"math\">1<\/span>.<br>\nHere, however, a bit of analysis shows that the answer turns out to always be <code>Yes<\/code>!<br>\nThe construction is simple: if the ones appear at indices <span class=\"math\">i_1, i_2, i_3, i_4<\/span> from left to right, we can simply use the ordering <span class=\"math\">(i_2, i_4, i_1, i_3)<\/span>.<\/p>\n<p>It\u2019s easy to see that a similar idea works for all larger counts too.<br>\nThat is, if the ones appear at positions <span class=\"math\">i_1, i_2, \\ldots, i_k<\/span> from left to right, where <span class=\"math\">k \\ge 4<\/span>, then we can always operate on all of them by following the order<br>\n<span class=\"math\">i_2, i_4, i_6, \\ldots, i_1, i_3, i_5, \\ldots<\/span><br>\nThat is, operate on all even-numbered ones from left to right; then all odd-numbered ones from left to right.<\/p>\n<hr>\n<p>From what we\u2019ve done above, we can see that the answer is almost always <code>Yes<\/code>.<br>\nThere are only two exceptional cases:<\/p>\n<ul>\n<li><span class=\"math\">S<\/span> contains two occurrences of <span class=\"math\">1<\/span>, and these occurrences are consecutive.<br>\nThat is, <span class=\"math\">S<\/span> looks like <span class=\"math\">00\\ldots 001100\\ldots 00<\/span><\/li>\n<li><span class=\"math\">S<\/span> contains three occurrences of <span class=\"math\">1<\/span>, and these occurrences are consecutive.<br>\nThat is, <span class=\"math\">S<\/span> looks like <span class=\"math\">00\\ldots 0011100\\ldots 00<\/span><\/li>\n<\/ul>\n<p>Both cases are easy to check in linear time; so we\u2019re able to easily answer <code>Yes<\/code> or <code>No<\/code>.<\/p>\n<h1><a name=\"time-complexity-6\" class=\"anchor\" href=\"#time-complexity-6\"><\/a>TIME COMPLEXITY:<\/h1>\n<p><span class=\"math\">\\mathcal{O}(N)<\/span> per testcase.<\/p>\n<h1><a name=\"code-7\" class=\"anchor\" href=\"#code-7\"><\/a>CODE:<\/h1>\n<details>\n<summary>\nEditorialist's code (PyPy3)<\/summary>\n<pre><code class=\"lang-python\">for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    l, r = 0, n-1\n    while l &lt; n:\n        if s[l] == '1': break\n        l += 1\n    while r &gt;= 0:\n        if s[r] == '1': break\n        r -= 1\n    \n    if l+1 == r or l+2 == r and s[l+1] == '1':\n        print('No')\n    else:\n        print('Yes')\n<\/code><\/pre>\n<\/details>",
  "text_editorial_is_markdown": 0,
  "text_editorial_topic_id": 124413,
  "languages_supported": "CPP20, PYTH 3, C, JAVA, PYP3, CS2, NODEJS, GO, TS, PHP, kotlin, rust, R",
  "max_timelimit": "1",
  "source_sizelimit": "50000",
  "problem_author": "archit_adm",
  "problem_display_authors": ["archit_adm"],
  "problem_display_authors_html_handle": "<div class=\"multiple-usernames-container\"><a href='\/users\/archit_adm'>archit_adm<\/a><\/div>",
  "problem_tester": null,
  "problem_testers_usernames": ["kingmessi"],
  "problem_tester_html_handle": "<div class=\"multiple-usernames-container\"><a href='\/users\/kingmessi'><span \n            class='rating' \n            style='display: inline-block; \n                    font-size: 10px; \n                    background: #D0011B;\n                    padding: 0 3px; \n                    line-height: 1.3; \n                    color: white;\n                    margin-right: 2px;'>7&#9733;<\/span><span class='m-username--link'>kingmessi<\/span><\/a><\/div>",
  "problem_editorialist": "iceknight1093",
  "date_added": "20-10-2025",
  "ready_for_debug": false,
  "problem_stats": {
    "accuracy": 9.1600000000000001,
    "successful_submissions": "1706",
    "total_submissions": "20695"
  },
  "user_tags": ["archit_adm", "simple", "start209"],
  "computed_tags": [],
  "difficulty_rating": "1626",
  "best_tag": "",
  "editorial_url": "",
  "time": {
    "view_start_date": 1761143406,
    "submit_start_date": 1761143406,
    "visible_start_date": 1761150606,
    "end_date": 1761150606,
    "current": 1761365590,
    "practice_submission_allowed": false
  },
  "user": { "username": null, "access": "default", "isPremiumUser": false },
  "bookmark_status": false,
  "contest_problem_status": "unattempted",
  "problem_status": "unattempted",
  "is_direct_submittable": false,
  "problemDiscussURL": "https:\/\/discuss.codechef.com\/search?q=P4209",
  "is_a_practice_or_college_contest": false,
  "votes_data": {
    "SolutionVoteData": { "upvote_count": 0, "user_vote": 0 },
    "HintsVoteData": { "upvote_count": 0, "user_vote": 0 },
    "ProblemStatementVoteData": { "upvote_count": 23, "user_vote": 0 },
    "DoubtSupportVoteData": { "upvote_count": 0, "user_vote": 0 }
  },
  "is_proctored": false,
  "is_user_verified_for_proctoring": false,
  "visitedContests": [],
  "isSupportedByJudge": true
}
